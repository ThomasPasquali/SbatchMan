use std::{fs::create_dir_all, io::Error, path::PathBuf};
use thiserror::Error;

use crate::core::{
  SbatchmanError,
  database::{
    self, StorageError,
    models::{Cluster, Config},
  },
};

#[derive(Error, Debug)]
pub enum ClusterConfigError {
  #[error("Storage Error: {0}")]
  StorageError(#[from] StorageError),
  #[error("SbatchMan not initialized: {0}")]
  SbatchMan(#[from] SbatchmanError),
  #[error("Could not find cluster: {0}")]
  ClusterNotFound(String),
  #[error("Could not find SbatchMan Project: {0}")]
  SbatchManProjectNotFound(#[from] std::io::Error),
}

pub struct ClusterConfig<'a> {
  pub cluster: &'a Cluster,
  pub config: &'a Config,
}

// impl Config {

//   pub fn to_cluster_config(self) -> Result<ClusterConfig, ClusterConfigError> {
//     // FIXME shall SbatchMan be passed as arg?
//     let mut sbm = Sbatchman::new().map_err(|e| ClusterConfigError::SbatchMan(e))?;
//     Ok(ClusterConfig {
//       cluster: sbm.db.get_cluster_by_id(self.cluster_id).map_err(|e| ClusterConfigError::ClusterNotFound(e))?,
//       config: self
//   })
// }

// }

impl<'a> ClusterConfig<'a> {
  // fn get_config_dir(&self, sbm: &Sbatchman) -> PathBuf {
  //   sbm.path.join("configs").join(self.cluster.cluster_name.clone())
  // }

  /// Ensure config directory exists and return its path
  // fn prepare_config_dir(&self, sbm: &Sbatchman) -> Result<PathBuf, ClusterConfigError> {
  //   let config_dir = self.get_config_dir(sbm);
  //   create_dir_all(&config_dir).map_err(|e| ClusterConfigError::SbatchManProjectNotFound(e))?;
  //   Ok(config_dir)
  // }

  /// Generate bash script header with job metadata
  /// This is used by all schedulers to create consistent script headers
  pub fn generate_script_header(&self) -> String {
    let mut script = String::new();
    script.push_str("#!/bin/bash\n");
    script.push_str("# ======================================================================\n");
    script.push_str("# This file was automatically generated by SbatchMan.\n");
    script.push_str("# Do not edit this file directly (unless you know what you are doing).\n");
    script.push_str("# --- Metadata ---\n");
    script.push_str(&format!("# ConfigName: {:?}\n", self.config.config_name));
    script.push_str(&format!("# Scheduler: {:?}\n", self.cluster.scheduler));
    script.push_str("# ======================================================================\n");
    script.push_str("\n");
    // TODO add scheduler fields
    script
  }

  /// Add environment variables from config to script
  /// This is used by all schedulers to set up the job environment
  pub fn add_environment_variables(&self, script: &mut String) {
    if let Some(env_obj) = self.config.env.as_object() {
      if !env_obj.is_empty() {
        script.push_str("# Environment variables\n");
        for (key, value) in env_obj {
          script.push_str(&format!("export {}={}\n", key, value.to_string()));
        }
        script.push_str("\n");
      }
    }
  }

  // Add preprocessing, main command, and postprocessing placeholders to script
  // pub fn add_commands_placeholder(&self, script: &mut String) {

  //       script.push_str("# Preprocessing (optional)\n");
  //   script.push_str("{PREPROCESSING}\n\n");

  //   script.push_str("# Main command\n");
  //   script.push_str("{COMMAND}\n\n");

  //       script.push_str("# Postprocessing (optional)\n");
  //   script.push_str("{POSTPROCESSING}\n\n");
  // }

  // fn create_script_template(&self) -> String {
  //   let mut script = self.generate_script_header();

  //   self.add_environment_variables(&mut script);
  //   self.add_commands_placeholder(&mut script);

  //   script
  // }

  // pub fn generate_and_store_script_template(&self) -> Result<PathBuf, ClusterConfigError> {
  //   let script_template_path = self.prepare_config_dir(sbm)?.join(format!("{}.sh", self.config.config_name));

  //   file
  //     .write_all(script_content.as_bytes())
  //     .map_err(|e| map_err_adding_description(e, "Failed to write script: {}"))?;

  //   Ok(script_template_path)
  // }
}
